---
title: "Writing Functions"
author: "Fonti Kar"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(janitor)
```

## A quick explainer on writing R functions

As researchers we often need to repeat our code operations. This often results in a lot of copy and pasting, making our R scripts/files realllly long. This also creates a problem of having to make changes to all your repeated code if you need to edit one thing. You can see how quickly things can get out of hand....

This is where functions can be useful. You write a function to do your operation!  This not only reduces your copy and paste load, but it also means you only need only change your code in your function **once** if you need to make any changes. 

Here's an example: 

We need to reach each penguin dataset and clean it. I've done it manually for 3 species and already you can see how much copy and pasting that requires! 

### Read in `af` data

```{r}
af <- read_csv("data/penguin_distributions/Aptenodytes forsteri.csv")
```

### Clean `af` data

```{r}
af |> 
  select(gbifID:species, individualCount,
         countryCode, locality, 
         institutionCode,
         decimalLongitude, decimalLatitude,
         eventDate, 
         coordinateUncertaintyInMeters) |> 
  filter(individualCount > 1,
         institutionCode %in% c("CLO", "iNaturalist")
         )|>
  arrange(eventDate) |> 
  clean_names() |> 
  write_csv("output/af.csv")
```

### Read in `ap` data

```{r}
ap <- read_csv("data/penguin_distributions/Aptenodytes patagonicus.csv")
```

### Clean `ap` data

```{r}
cleaned_ap <- ap |> 
  select(gbifID:species, individualCount,
         countryCode, locality, 
         institutionCode,
         decimalLongitude, decimalLatitude,
         eventDate, 
         coordinateUncertaintyInMeters) |> 
  filter(individualCount > 1,
         institutionCode %in% c("CLO", "iNaturalist")
         )|>
  arrange(eventDate) |> 
  clean_names() 

cleaned_ap |> 
  write_csv("output/ap.csv")
```

### Read in `ec` data

```{r}
ec <- read_csv("data/penguin_distributions/Eudyptes chrysocome.csv")
```

### Clean `ec` data

```{r}
cleaned_ec <- ec |> 
  select(gbifID:species, individualCount,
         countryCode, locality, 
         institutionCode,
         decimalLongitude, decimalLatitude,
         eventDate, 
         coordinateUncertaintyInMeters) |> 
  filter(individualCount > 1,
         institutionCode %in% c("CLO", "iNaturalist")
         )|>
  arrange(eventDate) |> 
  clean_names() 

cleaned_ec |> 
  write_csv("output/ec.csv")
```

## A function to clean your data data

So here I've decided that was too much work and I need to write a function. I've called my function `prepare_data_for_plot`. Give your functions a clear, declarative name of what it does. Not `my_function`, something meaningful. 

- To write your function, we use the `function()` function. The inputs you put inside `function()`, are the **inputs** you will have for your function. Here, my function will take an input `data`. 

- The `{    }` is where you define the body of your function. This is where I've pasted my repeated data cleaning code. 

Notice how I've assigned the output of my cleaning pipe to `cleaned_data` and at the end of my function I've called the `return(cleaned_data)` so that when I call my `prepare_data_for_plot()` it will also print the `cleaned_data` object into the console 

```{r}
prepare_data_for_plot <- function(data){
  
  cleaned_data <- data |> 
  select(gbifID:species, individualCount, # Selecting specific cols
         countryCode, locality, 
         institutionCode,
         decimalLongitude, decimalLatitude,
         eventDate, 
         coordinateUncertaintyInMeters) |> 
  filter(individualCount > 1, # Exclude records with less 1 individual count
         institutionCode %in% c("CLO", "iNaturalist")
         )|>
  arrange(eventDate) |>  # Sort by date
  clean_names()  # clean colname names

  return(cleaned_data)
  
}

prepare_data_for_plot(af)
prepare_data_for_plot(ap)
prepare_data_for_plot(ec)

cleaned_af <- prepare_data_for_plot(af)
```

## A function for quick summaries

Something we often need to do is to get some descriptive stats on our data. The functions: `group_by()` and `summarise()` are really useful for this sort of task but what we if needed to generate descriptive statistics more than once? 

Lets say I need to know the number of observations for each level of `species`, how I usually need to do this?

```{r}
cleaned_af |> 
  group_by(species) |> 
  summarise(n_obs = n())
```

OK, I also need it for each level of `country_code` and `institution_code`

I _could_ do some copying and pasting...

```{r}
cleaned_af |> 
  group_by(institution_code) |> 
  summarise(n_obs = n())

cleaned_af |> 
  group_by(country_code) |> 
  summarise(n_obs = n())
```

OR I could write a function! Now, since we are using tidyverse style of coding, we have to learn a few tricks about how to program tidy functions. 

One amazing benefit of tidyverse packages and function is the ability to not have to quote your variable names. You can just type `country_code` and the function will know that `country_code` is a variable inside the dataframe. This unique-coolness tidyverse functions is called **non-standard evaluation or NSE** and its actually not unique to tidyverse.  See `subset()` for example. 

For researchers to write useful functions, we need to be able to program NSE in our own functions. In our function where we want to supply **ANY variable name**, we need to **double-embrace** the variable name input like this `{{var}}`

```{r}
count_n_obs <- function(data, var){
  cleaned_af |> 
  group_by(country_code) |> 
  summarise(n_obs = n())
}

count_n_obs <- function(data, var){
  data |> 
  group_by({{var}}) |> 
  summarise(n_obs = n())
}

cleaned_af |> 
  count_n_obs(country_code)

cleaned_af |> 
  count_n_obs(institution_code)
```

Exercises: 

- Write a `group_by()` `summarise()` function to compute the median of a numeric value. Try it our on individual count

```{r}
group_median <- function(data, group_var, med_var){
  data |> 
  group_by({{group_var}}) |> 
  summarise(median = median({{med_var}}))
}

cleaned_af |> group_median(institution_code, individual_count)
```


- Create a new variable called `infraspecific_epiphet` where the second word of species is the value. You may need to use `stringr`

```{r}
library(stringr)

cleaned_af <- cleaned_af |> 
  mutate(infraspecific_epiphet = word(species, 2)) |> 
  relocate(infraspecific_epiphet, .after = genus) 
```

- Write a function that will join `genus` strings together separated by a `_` that you can use alongside `mutate()` 

```{r}
join_underscore <- function(genus, epiphet){
  paste(genus, epiphet, sep = "_")
}

join_underscore(letters, LETTERS)

cleaned_af |> 
  mutate(species_underscore = join_underscore(genus, infraspecific_epiphet)) |> 
  pull(species_underscore)
```

- Write a function that will take the `occurrence_id` and remove all the letters so that we get `OBSXXXXXXXX`. You may need to use `stringr`

```{r}
cleaned_af$occurrence_id

str_subset(cleaned_af$occurrence_id, regex("[0-9]"))
str_split(cleaned_af$occurrence_id, ":", simplify = TRUE)[,5]
```


## A function for quick data visualisations

Another common task for researchers is to quickly generate some data visualisations to get a sense of their data. Here we will use `ggplot2`. 

Let's say I want to create a histogram our numeric variables, so I can check if there are any rogue data points. I will write the code out once and format the plot to how I want it. 
```{r}
ggplot(data = cleaned_af, aes(x = decimal_latitude)) +
  geom_histogram(bins = 50, fill = "seagreen") + 
  xlab("Latitude") +
  ylab("Number of records") +
  ggtitle(cleaned_af$species |> unique()) + 
  theme_minimal()
```

Now let's try stick it in a function. 
 
Identify your inputs! 

- What's coming in? 
- What variable do you expect to change? 
- What parts of the code do you expect to change?

```{r}
quick_histogram <- function(data, var, group_var){
  ggplot(data = data, aes(x = {{var}})) +
  geom_histogram(bins = 50, fill = "seagreen") + 
  ylab("Number of records") +
  theme_minimal()
}

cleaned_af |> quick_histogram(decimal_longitude)
cleaned_af |> quick_histogram(individual_count, species)
```

Exercises: 

- Write a function where you can plot any numeric variable as a violin plot

```{r}
quick_violin <- function(data, y_var, x_var){
ggplot(data = cleaned_af, aes(y = {{y_var}}, x = {{x_var}})) +
  geom_violin(colour = "seagreen") + 
  geom_point(alpha = 0.1) +
  theme_minimal()
}

ggplot(data = cleaned_af, aes(y = decimal_latitude, x = species)) +
  geom_violin(colour = "seagreen") + 
  geom_point(alpha = 0.1) +
  theme_minimal()

quick_violin(cleaned_af, decimal_latitude, country_code)
quick_violin(cleaned_ap, individual_count, institution_code)
```

- Amend the function above: Add an input variable for whether to plot `individual_count` on log10 scale or not. 
```{r}
# Generate the plot once
ggplot(data = cleaned_af, aes(y = individual_count, x = species)) +
  geom_violin(colour = "seagreen") + 
  geom_point(alpha = 0.1) +
  scale_y_log10() +
  theme_minimal()

quick_violin <- function(data, y_var, x_var, y_log10){

  base <- ggplot(data = cleaned_af, aes(y = {{y_var}}, x = {{x_var}})) +
  geom_violin(colour = "seagreen") + 
  geom_point(alpha = 0.1) +
  theme_minimal()
  
if(y_log10 == TRUE) 
 base <- base + scale_y_log10()

return(base)
}

quick_violin(cleaned_ec, individual_count, species, FALSE)
quick_violin(cleaned_ec, individual_count, species, TRUE)
```

- Write a function to save a ggplot object where the default file path is the `output/fig/` folder. Tip - check if the file path exists and if not, create it. 

```{r}
save_plot <- function(gg_obj, file_name, path = "output/fig/", ...){
  if(! file.exists(path)){
    dir.create(path)
  }
  ggsave(file_name, path = path, plot = gg_obj, ...)
}

p1 <- quick_violin(cleaned_af, individual_count, species, TRUE)
save_plot(p1, "plot.png")
```

## Argh, help my function isn't working

Sometimes, you can't get your function to work and you have no idea why. There are few strategies here: 

- Go swimming with `browser()`
  - You can also do that with a breakpoint with RStudio
- Add a `print()` or a `str()` to force the function to tell you what you want to work with
- ChatGPT is pretty good too


```{r}
browser() 
```




- Bonus: Write a wrapper function that

```{r}
quick_viz <- function(data, y_var, x_var, type) {
  y_var <- enquo(y_var)
  x_var <- enquo(x_var)
  
  if (type == "boxplot") {
    quick_boxplot(data, !!y_var, !!x_var)
  } else if (type == "violin") {
    quick_violin(data, !!y_var, !!x_var)
  } else {
    stop("Invalid type. Please use 'boxplot' or 'violin'.")
  }
}

quick_violin <- function(data, y_var, x_var) {
  ggplot(data = data, aes(y = {{ y_var }}, x = {{ x_var }})) +
    geom_violin(colour = "seagreen") + 
    geom_point(alpha = 0.1) +
    theme_minimal()
}

quick_boxplot <- function(data, y_var, x_var) {
  ggplot(data = data, aes(y = {{ y_var }}, x = {{ x_var }})) +
    geom_boxplot(colour = "seagreen") + 
    geom_point(alpha = 0.1) +
    theme_minimal()
}

quick_viz(cleaned_af, individual_count, species, type = "violin")
quick_viz(cleaned_af, decimal_latitude, species, type = "boxplot")
```

